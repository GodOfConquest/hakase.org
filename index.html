<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">

<title>hakase.org</title>
<meta name="description" content="Because it's cute!">

<link rel="icon" href="favicon.ico">

<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

<style>
  html {
    min-height: 100%;
    background: url(bg.png), -moz-radial-gradient(center, ellipse cover, #fafafa 70%, #c6c6c6 100%); /* FF3.6+ */
    background: -url(bg.png), webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(70%,#fafafa), color-stop(100%,#c6c6c6)); /* Chrome,Safari4+ */
    background: url(bg.png), -webkit-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* Chrome10+,Safari5.1+ */
    background: url(bg.png), -o-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* Opera 12+ */
    background: url(bg.png), -ms-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* IE10+ */
    background: url(bg.png), radial-gradient(ellipse at center, #fafafa 70%,#c6c6c6 100%); /* W3C */
  }

  html, body, h1 { margin: 0; padding: 0; }

  body {
    font-family: 'Droid Serif', serif;
  }

  #title {
    font-weight: 700;
    font-size: 150px;
    text-align: center;

    color: white;
    text-shadow: 3px 3px 0 black, 8px 8px 15px #aaa;

    margin: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
    height: 150px;
  }

  /* the containing nav element is actually a fairly extensive hack to get the
  bottom-right counter-rounded corner to display _without_ making a scrollbar
  on the body, or having to set overflow-hidden on the html element itself,
  which prevents scrolling.  By having the nav containing element set to 100%
  of the page size, its own overflow: hidden can contain the tiny bottom-right
  #nav:after piece, giving us the effect we desire. so. cool.*/
  nav {
    margin: 0;
    padding: 0;

    position: absolute;
    top: 0;
    right: 0;
    width: 100%;
    height: 100%;

    overflow: hidden;

    z-index: -1;
  }

  #nav {
    margin: 0;
    padding: 0 5px 0 5px;

    position: absolute;
    top: 0;
    right: 0;

    background: #222;
    border-bottom-left-radius: 5px;

    text-align: right;

    z-index: 11;
  }

  #nav:before {
    content: "";

    border-color: #222222;
    border-style: solid;
    border-top-right-radius: 10px;
    border-width: 5px 5px 0 0;

    height: 5px;
    width: 5px;

    position: absolute;
    left: -5px;
    top: -5px;
  }

  #nav:after {
    content: "";

    border-color: #222222;
    border-style: solid;
    border-top-right-radius: 10px;
    border-width: 5px 5px 0 0;

    height: 5px;
    width: 5px;

    position: absolute;
    bottom: -5px;
    right: -5px;
  }

  #nav li {
    display: inline;
    margin: 0;
    padding: 0;
  }

  #nav a {
    display: inline-block;
    height: 100%;
    padding: 0.5em;
    margin: 0;

    color: #ccc;
    text-decoration: none;
  }

  #nav a:hover {
    color: white;
  }

  #hakase {
    position: absolute;
    bottom: 0;
  }

  section {
    visibility: hidden;
    margin: auto;
    position: absolute;
    top: 0;
    bottom: 0;

    width: 100%;
    min-width: 320px;
    height: 50%;

    z-index: 100;

    opacity: 0;

    pointer-events: none;
  }

  section > div {
    pointer-events: all; /* let return click through the sides */

    margin: 0 auto;
    width: 50%;
    min-width: 320px;
    height: 100%;
    padding: .5em;

    box-sizing: border-box;
    -ms-box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    -o-box-sizing: border-box;

    overflow-y: auto;
    background-color: rgba(240, 240, 240, 0.98);
    box-shadow: 0 0 15px 15px rgba(240, 240, 240, 0.98);
  }

  #return {
    opacity: 0;

    visibility: hidden;
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;

    z-index: 10;
    background-color: rgba(0,0,0,0.15);
  }

  /* really clever way to click out of lightboxes, if I do say so myself */
  section:target, section:target ~ #return {
    visibility: visible;
    opacity: 1;
  }

  section, #return {
    transition: 1s;
    -moz-transition: 1s;
    -ms-transition: 1s;
    -webkit-transition: 1s;
    -o-transition: 1s;
  }

  p {
    line-height: 1.6em; /* TODO actual vertical rhythm */
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>

<h1 id="title">hakase.org</h1>

<nav>
  <ul id="nav"> <!-- see note in CSS about why there's a container -->
    <li><a href="#news">News
    </a></li><li><a href="#projects">Projects
    </a></li><li><a href="#about">About</a></li>
  </ul> <!-- ^ nonstandard linebreaks prevent whitespace between elements -->
</nav>

<section id="news">
  <div>
    <h1>News</h1>
    <p>Expect cool things!
  </div>
</section>

<section id="projects">
  <div>
    <h1>Projects</h1>
    <p>Nothing yet!
  </div>
</section>

<section id="about">
  <div>
    <h1>About</h1>
    <p>A website, in your browser! How novel!
    <p><i>hakase.org</i> is designed and maintained by <a
        href="mailto:queue@lavabit.com">queue</a>. You can stare at this
      website's source code on <a
        href="https://github.com/qqueue/hakase.org">Github</a> if you want.
  </div>
</section>

<a id="return" href="#"></a>

<canvas id="hakase" height="119">hakase.org</canvas>

<script>
(function () {
"use strict";

// stretch title stuff
// adapted from https://github.com/davatron5000/FitText.js

function debounce(time, fn) {
  var timeout;
  return function () {
    var ctx = this, args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn.apply(this, args);
    }, time);
  };
}

// behold my carefully tuned constants
function resize() {
  var h1 = document.getElementById('title');
  h1.style.fontSize = (window.innerWidth / 7) + 'px';
  h1.style.height = (window.innerWidth / 5) + 'px';
}

document.addEventListener('DOMContentLoaded', function () {
  resize();
  window.addEventListener('resize', debounce(300, resize));
});

// page visibility API polyfill
if (typeof document.hidden !== "undefined") {
  (function () {
    var hidden, visibilityChange;
    if (typeof document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }

    // set the real document.hidden property, and dispatch the polyfilled event
    document.addEventListener(visibilityChange, function () {
      document.hidden = document[hidden];
      document.dispatchEvent(new CustomEvent("visibilitychange"));
    });
  })();
}

// The parts of the animation overlap slightly, so this is the true width
// to shift the container by when moving
var TURN_WIDTH_LEFT = 55,
    TURN_WIDTH_RIGHT = 170,
    WALK_LEFT_START = 266,
    WALK_RIGHT_START = 150,
    WALK_WIDTH = {
      left: [-27, -32, -19, -22, -25],
      right: [27, 32, 19, 22, 25]
    };

document.addEventListener('DOMContentLoaded', function () {

  var hakase = document.getElementById('hakase'),
      ctx = hakase.getContext('2d'),

      // start animation after all the images load
      total_assets = 5 + 5 + 14 + 16,
      onload = function () {
        if (--total_assets == 0) { tick(); }
      },
      load = function (src) {
        var img = new Image;
        img.src = src;
        img.onload = onload;
        return img;
      },
      walk = {
        left: [
          "walk/left/0.png",
          "walk/left/1.png",
          "walk/left/2.png",
          "walk/left/3.png",
          "walk/left/4.png"
        ].map(load),
        right: [
          "walk/right/0.png",
          "walk/right/1.png",
          "walk/right/2.png",
          "walk/right/3.png",
          "walk/right/4.png"
        ].map(load)
      },
      turn = {
        left: [
          "turn/left/0.png",
          "turn/left/1.png",
          "turn/left/2.png",
          "turn/left/3.png",
          "turn/left/4.png",
          "turn/left/5.png",
          "turn/left/6.png",
          "turn/left/7.png",
          "turn/left/8.png",
          "turn/left/9.png",
          "turn/left/10.png",
          "turn/left/11.png",
          "turn/left/12.png",
          "turn/left/13.png"
        ].map(load),
        right: [
          "turn/right/0.png",
          "turn/right/1.png",
          "turn/right/2.png",
          "turn/right/3.png",
          "turn/right/4.png",
          "turn/right/5.png",
          "turn/right/6.png",
          "turn/right/7.png",
          "turn/right/8.png",
          "turn/right/9.png",
          "turn/right/10.png",
          "turn/right/11.png",
          "turn/right/12.png",
          "turn/right/13.png",
          "turn/right/14.png",
          "turn/right/15.png"
        ].map(load)
      },

      x         = -250, // cutely walk into the screen from stage left
      walking   = true,
      direction = "right",
      anim      = walk[direction],
      frames    = anim.length,
      frame     = 0,

      draw = function () {
        // resetting the canvas width has the added effect of clearing it
        hakase.width = window.innerWidth;

        // not all the images are the same height, and it's a goddamn hassle to
        // either figure out how to script them to the same height, or to do it
        // manually with GIMP's god-awful interface
        ctx.drawImage(anim[frame], x, 119 - anim[frame].height);
      };

  // animation loop
  function tick () {
    ++frame;

    if (walking) {
      frame = frame % frames;

      x += WALK_WIDTH[direction][frame];

      if ( direction === "right" && (window.innerWidth - x) < TURN_WIDTH_RIGHT ||
           direction === "left" && x < TURN_WIDTH_LEFT ) {

        walking = false;
        if (direction === "right") {
          direction = "left";
          x = window.innerWidth - 266; // width of actual turning anim
        } else { // left
          direction = "right";
          x = 0;
        }

        anim = turn[direction];
        frames = anim.length;
        frame = 0;
      }
    } else { // turning
      if (frame >= frames) {
        walking = true;
        anim = walk[direction];
        frames = anim.length;
        frame = 0;

        x = direction === "right" ?
          WALK_RIGHT_START :
          window.innerWidth - WALK_LEFT_START;
      }
    }

    draw();

    if (document.hidden) {
      // continue once we're no longer hidden
      document.addEventListener("visibilitychange", function restart () {
        setTimeout(tick, 120);
        document.removeEventListener("visibilitychange", restart);
      });
    } else {
      setTimeout(tick, 120);
    }
  }
});
})();
</script>

</body>
</html>
